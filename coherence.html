<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>COHERENCE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&family=Orbitron:wght@700&display=swap');
        
        :root {
            --signal-green: #00ff41;
            --signal-amber: #ffaa00;
            --signal-red: #ff0044;
            --void: #0a0e27;
            --grid-line: #1a2456;
            --text-dim: #4a5f8f;
            --text-bright: #e0e8ff;
            --distortion: #ff0088;
            --anchor: #00ffff;
            --threshold: #ffaa00;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--void);
            color: var(--text-bright);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            position: relative;
        }
        
        /* Scanline effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 255, 65, 0.03) 0px,
                transparent 1px,
                transparent 2px,
                rgba(0, 255, 65, 0.03) 3px
            );
            pointer-events: none;
            z-index: 1000;
            animation: scanline 8s linear infinite;
        }
        
        @keyframes scanline {
            0% { transform: translateY(0); }
            100% { transform: translateY(100px); }
        }
        
        /* Subtle noise texture */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.05'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 999;
        }
        
        .container {
            position: relative;
            z-index: 2;
            text-align: center;
        }
        
        header {
            margin-bottom: 2rem;
            animation: fadeIn 1s ease-out;
        }
        
        h1 {
            font-family: 'Orbitron', monospace;
            font-size: 3rem;
            font-weight: 700;
            letter-spacing: 0.5rem;
            text-transform: uppercase;
            background: linear-gradient(135deg, var(--signal-green), var(--signal-amber));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
            margin-bottom: 0.5rem;
        }
        
        .subtitle {
            font-size: 0.9rem;
            color: var(--text-dim);
            letter-spacing: 0.3rem;
            text-transform: uppercase;
        }
        
        #game-container {
            background: rgba(10, 14, 39, 0.8);
            border: 2px solid var(--grid-line);
            padding: 2rem;
            border-radius: 4px;
            box-shadow: 
                0 0 40px rgba(0, 255, 65, 0.1),
                inset 0 0 40px rgba(0, 0, 0, 0.5);
            animation: fadeIn 1s ease-out 0.3s both;
        }
        
        #grid {
            display: inline-block;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 1.8rem;
            line-height: 1.4;
            letter-spacing: 0.3rem;
            background: rgba(0, 0, 0, 0.6);
            padding: 1.5rem;
            border: 1px solid var(--grid-line);
            border-radius: 2px;
            white-space: pre;
            position: relative;
        }
        
        .tile {
            display: inline-block;
            transition: all 0.2s ease;
        }
        
        .player { 
            color: var(--signal-green); 
            font-weight: 600;
            text-shadow: 0 0 10px var(--signal-green);
            animation: pulse 2s ease-in-out infinite;
        }
        
        .ground { color: var(--text-dim); opacity: 0.3; }
        .boundary { color: var(--grid-line); font-weight: 600; }
        .distortion { 
            color: var(--distortion); 
            font-weight: 600;
            text-shadow: 0 0 8px var(--distortion);
            animation: flicker 3s ease-in-out infinite;
        }
        .anchor { 
            color: var(--anchor); 
            font-weight: 600;
            text-shadow: 0 0 10px var(--anchor);
            animation: glow 2s ease-in-out infinite;
        }
        .threshold { 
            color: var(--threshold); 
            font-weight: 600;
            text-shadow: 0 0 6px var(--threshold);
        }
        .artifact { 
            color: #ffd700; 
            font-weight: 600;
            text-shadow: 0 0 10px #ffd700;
            animation: sparkle 1.5s ease-in-out infinite;
        }
        .exit { 
            color: var(--signal-green); 
            font-weight: 600;
            text-shadow: 0 0 12px var(--signal-green);
            font-size: 2rem;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            45%, 55% { opacity: 0.6; }
            50% { opacity: 0.8; }
        }
        
        @keyframes glow {
            0%, 100% { text-shadow: 0 0 10px var(--anchor); }
            50% { text-shadow: 0 0 20px var(--anchor), 0 0 30px var(--anchor); }
        }
        
        @keyframes sparkle {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        #status {
            margin-top: 2rem;
            font-size: 1.1rem;
            letter-spacing: 0.2rem;
            padding: 1rem 2rem;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid var(--grid-line);
            border-radius: 2px;
            display: inline-block;
        }
        
        .coh-value {
            font-weight: 600;
            transition: color 0.3s ease;
        }
        
        .coh-high { color: var(--signal-green); }
        .coh-medium { color: var(--signal-amber); }
        .coh-low { color: var(--signal-red); text-shadow: 0 0 8px var(--signal-red); }
        
        .state-stable { color: var(--signal-green); }
        .state-searching { color: var(--signal-amber); }
        .state-altered { color: var(--anchor); }
        .state-critical { color: var(--signal-red); animation: pulse 1s ease-in-out infinite; }
        
        #modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        
        #modal.active {
            display: flex;
        }
        
        .modal-content {
            background: var(--void);
            border: 2px solid var(--grid-line);
            padding: 2rem;
            border-radius: 4px;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 0 40px rgba(0, 255, 65, 0.2);
            animation: fadeIn 0.3s ease-out;
        }
        
        .modal-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.5rem;
            color: var(--signal-amber);
            margin-bottom: 1rem;
            letter-spacing: 0.2rem;
        }
        
        .modal-text {
            color: var(--text-bright);
            margin-bottom: 1.5rem;
            line-height: 1.6;
        }
        
        .modal-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }
        
        button {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 1rem;
            padding: 0.75rem 2rem;
            background: transparent;
            border: 2px solid var(--signal-green);
            color: var(--signal-green);
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.1rem;
        }
        
        button:hover {
            background: var(--signal-green);
            color: var(--void);
            box-shadow: 0 0 20px var(--signal-green);
        }
        
        button.secondary {
            border-color: var(--text-dim);
            color: var(--text-dim);
        }
        
        button.secondary:hover {
            background: var(--text-dim);
            color: var(--void);
            box-shadow: 0 0 20px var(--text-dim);
        }
        
        .instructions {
            margin-top: 2rem;
            font-size: 0.85rem;
            color: var(--text-dim);
            letter-spacing: 0.1rem;
            animation: fadeIn 1s ease-out 0.6s both;
        }
        
        .glitch {
            animation: glitchShake 0.3s ease-in-out;
        }
        
        @keyframes glitchShake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-2px, 2px); }
            50% { transform: translate(2px, -2px); }
            75% { transform: translate(-2px, -2px); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>COHERENCE</h1>
            <div class="subtitle">Signal Decay Protocol</div>
        </header>
        
        <div id="game-container">
            <div id="grid"></div>
            <div id="status">
                COH: <span id="coh-value" class="coh-value coh-high">20</span> | 
                STATE: <span id="state-value" class="state-stable">STABLE</span> | 
                CARRY: <span id="carry-value">NONE</span>
            </div>
        </div>
        
        <div class="instructions">
            USE ARROW KEYS TO MOVE • REACH THE EXIT BEFORE SIGNAL LOSS
        </div>
    </div>
    
    <div id="modal">
        <div class="modal-content">
            <div class="modal-title" id="modal-title"></div>
            <div class="modal-text" id="modal-text"></div>
            <div class="modal-buttons" id="modal-buttons"></div>
        </div>
    </div>
    
    <script>
        // Game State
        const gameState = {
            grid: [],
            playerPos: { x: 1, y: 1 },
            coherence: 20,
            belowThreshold: false,
            turnCounter: 0,
            carriedArtifact: null,
            gameOver: false,
            won: false,
            anchorUsed: false,
            thresholdRow: 5
        };
        
        // Artifact definitions
        const artifacts = [
            {
                name: "RESONANCE INVERTER",
                description: "Distortions become Anchors. Anchors become Distortions.",
                cohBonus: 6,
                effect: "invert"
            },
            {
                name: "CLARITY LENS",
                description: "See the pattern, pay the price. +1 drain per turn.",
                cohBonus: 6,
                effect: "clarity"
            },
            {
                name: "SEVERANCE",
                description: "Immune to distortion adjacency. Anchors no longer function.",
                cohBonus: 6,
                effect: "sever"
            }
        ];
        
        // Initial grid layout
        const initialGrid = [
            ['#','#','#','#','#','#','#','#','#','#','#','#','#'],
            ['#','@','.','.','.','.','.','.','.','.','.','X','#'],
            ['#','.','.','.','.','.','.','.','.','.','.','.','#'],
            ['#','.','.','.','.','~','.','.','.','.','.','.','#'],
            ['#','.','.','.','*','.','.','.','.','.','.','.','.','#'],
            ['#','+','+','+','+','+','+','+','+','+','+','+','#'],
            ['#','.','.','.','.','*','.','.','.','.','.','.','#'],
            ['#','.','.','.','.','O','.','.','.','.','.','.','#'],
            ['#','.','.','~','.','.','.','.','.','.','.','.','#'],
            ['#','.','.','.','.','.','.','*','.','.','.','.','#'],
            ['#','.','.','.','.','*','.','.','.','.','.','.','#'],
            ['#','.','.','.','.','~','.','.','.','.','.','.','#'],
            ['#','#','#','#','#','#','#','#','#','#','#','#','#']
        ];
        
        // Initialize game
        function initGame() {
            gameState.grid = initialGrid.map(row => [...row]);
            gameState.grid[gameState.playerPos.y][gameState.playerPos.x] = '.';
            renderGrid();
            updateStatus();
        }
        
        // Render the grid
        function renderGrid() {
            const gridElement = document.getElementById('grid');
            let html = '';
            
            for (let y = 0; y < gameState.grid.length; y++) {
                for (let x = 0; x < gameState.grid[y].length; x++) {
                    let tile = gameState.grid[y][x];
                    let className = '';
                    
                    // Player position
                    if (x === gameState.playerPos.x && y === gameState.playerPos.y) {
                        tile = '@';
                        className = 'player';
                    } else {
                        // Apply classes based on tile type
                        switch(tile) {
                            case '.': className = 'ground'; break;
                            case '#': className = 'boundary'; break;
                            case '~': className = 'distortion'; break;
                            case 'O': className = 'anchor'; break;
                            case '+': className = 'threshold'; break;
                            case '*': className = 'artifact'; break;
                            case 'X': className = 'exit'; break;
                        }
                    }
                    
                    html += `<span class="tile ${className}">${tile}</span>`;
                }
                html += '\n';
            }
            
            gridElement.innerHTML = html;
        }
        
        // Update status line
        function updateStatus() {
            const cohValue = document.getElementById('coh-value');
            const stateValue = document.getElementById('state-value');
            const carryValue = document.getElementById('carry-value');
            
            // Update coherence
            cohValue.textContent = gameState.coherence;
            cohValue.className = 'coh-value';
            if (gameState.coherence >= 15) {
                cohValue.classList.add('coh-high');
            } else if (gameState.coherence >= 8) {
                cohValue.classList.add('coh-medium');
            } else {
                cohValue.classList.add('coh-low');
            }
            
            // Update state
            let state = 'STABLE';
            let stateClass = 'state-stable';
            
            if (gameState.coherence < 5) {
                state = 'CRITICAL';
                stateClass = 'state-critical';
            } else if (gameState.carriedArtifact) {
                state = 'ALTERED';
                stateClass = 'state-altered';
            } else if (gameState.belowThreshold) {
                state = 'SEARCHING';
                stateClass = 'state-searching';
            }
            
            stateValue.textContent = state;
            stateValue.className = stateClass;
            
            // Update carried item
            carryValue.textContent = gameState.carriedArtifact ? gameState.carriedArtifact.name : 'NONE';
        }
        
        // Handle movement
        function movePlayer(dx, dy) {
            if (gameState.gameOver) return;
            
            const newX = gameState.playerPos.x + dx;
            const newY = gameState.playerPos.y + dy;
            
            // Check boundaries
            if (gameState.grid[newY][newX] === '#') {
                // Glitch effect on collision
                document.getElementById('grid').classList.add('glitch');
                setTimeout(() => {
                    document.getElementById('grid').classList.remove('glitch');
                }, 300);
                return;
            }
            
            // Move player
            gameState.playerPos.x = newX;
            gameState.playerPos.y = newY;
            
            // Process turn
            processTurn();
        }
        
        // Process a game turn
        function processTurn() {
            gameState.turnCounter++;
            
            // Base movement cost
            let cohCost = 1;
            
            // Clarity lens effect
            if (gameState.carriedArtifact && gameState.carriedArtifact.effect === 'clarity') {
                cohCost += 1;
            }
            
            gameState.coherence -= cohCost;
            
            // Check current tile
            const currentTile = gameState.grid[gameState.playerPos.y][gameState.playerPos.x];
            
            // Exit check
            if (currentTile === 'X') {
                winGame();
                return;
            }
            
            // Anchor check
            if (currentTile === 'O' && !gameState.anchorUsed) {
                if (!gameState.carriedArtifact || gameState.carriedArtifact.effect !== 'sever') {
                    const invert = gameState.carriedArtifact && gameState.carriedArtifact.effect === 'invert';
                    if (!invert) {
                        gameState.coherence += 10;
                        gameState.grid[gameState.playerPos.y][gameState.playerPos.x] = '.';
                        showMessage('ANCHOR ACTIVATED', '+10 COHERENCE', false);
                    }
                } else {
                    // Severance: anchor doesn't work
                    showMessage('ANCHOR INERT', 'SEVERANCE PREVENTS RESTORATION', false);
                }
            }
            
            // Artifact pickup check
            if (currentTile === '*') {
                handleArtifactPickup();
                return;
            }
            
            // Threshold crossing check
            if (currentTile === '+' && !gameState.belowThreshold) {
                gameState.belowThreshold = true;
                showMessage('THRESHOLD CROSSED', 'DISTORTION FIELD ACTIVE • NO RETURN', false);
            }
            
            // Distortion adjacency/standing check
            checkDistortionDrain();
            
            // Post-threshold spreading
            if (gameState.belowThreshold && gameState.turnCounter % 3 === 0) {
                spreadDistortions();
            }
            
            // Coherence check
            if (gameState.coherence <= 0) {
                loseGame();
                return;
            }
            
            renderGrid();
            updateStatus();
        }
        
        // Check for distortion drain
        function checkDistortionDrain() {
            const px = gameState.playerPos.x;
            const py = gameState.playerPos.y;
            const currentTile = gameState.grid[py][px];
            
            // If carrying severance artifact, immune to distortion
            if (gameState.carriedArtifact && gameState.carriedArtifact.effect === 'sever') {
                return;
            }
            
            const invert = gameState.carriedArtifact && gameState.carriedArtifact.effect === 'invert';
            
            // Standing on distortion
            if (currentTile === '~') {
                if (!invert) {
                    gameState.coherence -= 2;
                } else {
                    gameState.coherence += 2; // Inverted: distortion heals
                }
                return;
            }
            
            // Check adjacent tiles (cardinal only)
            const adjacent = [
                {x: px-1, y: py},
                {x: px+1, y: py},
                {x: px, y: py-1},
                {x: px, y: py+1}
            ];
            
            for (let pos of adjacent) {
                if (pos.y >= 0 && pos.y < gameState.grid.length && 
                    pos.x >= 0 && pos.x < gameState.grid[pos.y].length) {
                    if (gameState.grid[pos.y][pos.x] === '~') {
                        if (!invert) {
                            gameState.coherence -= 1;
                        } else {
                            gameState.coherence += 1; // Inverted: adjacency heals
                        }
                        return; // Only drain once even if multiple adjacent
                    }
                }
            }
        }
        
        // Spread distortions
        function spreadDistortions() {
            const distortions = [];
            
            // Find all current distortions
            for (let y = 0; y < gameState.grid.length; y++) {
                for (let x = 0; x < gameState.grid[y].length; x++) {
                    if (gameState.grid[y][x] === '~') {
                        distortions.push({x, y});
                    }
                }
            }
            
            // Spawn new distortions
            for (let distortion of distortions) {
                const directions = [
                    {x: -1, y: 0},
                    {x: 1, y: 0},
                    {x: 0, y: -1},
                    {x: 0, y: 1}
                ];
                
                // Pick random direction
                const dir = directions[Math.floor(Math.random() * directions.length)];
                const newX = distortion.x + dir.x;
                const newY = distortion.y + dir.y;
                
                // Spawn if valid and empty
                if (newY >= 0 && newY < gameState.grid.length &&
                    newX >= 0 && newX < gameState.grid[newY].length &&
                    gameState.grid[newY][newX] === '.') {
                    gameState.grid[newY][newX] = '~';
                }
            }
        }
        
        // Handle artifact pickup
        function handleArtifactPickup() {
            if (gameState.carriedArtifact) {
                showMessage('INVENTORY FULL', 'Cannot carry more artifacts', false);
                return;
            }
            
            // Pick random artifact
            const artifact = artifacts[Math.floor(Math.random() * artifacts.length)];
            
            showArtifactPrompt(artifact);
        }
        
        // Show artifact pickup prompt
        function showArtifactPrompt(artifact) {
            const modal = document.getElementById('modal');
            const title = document.getElementById('modal-title');
            const text = document.getElementById('modal-text');
            const buttons = document.getElementById('modal-buttons');
            
            title.textContent = `ARTIFACT: ${artifact.name}`;
            text.innerHTML = `
                ${artifact.description}<br><br>
                <strong>IMMEDIATE: +${artifact.cohBonus} COHERENCE</strong>
            `;
            
            buttons.innerHTML = `
                <button onclick="acceptArtifact(${artifacts.indexOf(artifact)})">ACCEPT</button>
                <button class="secondary" onclick="declineArtifact()">DECLINE</button>
            `;
            
            modal.classList.add('active');
        }
        
        // Accept artifact
        function acceptArtifact(index) {
            const artifact = artifacts[index];
            gameState.carriedArtifact = artifact;
            gameState.coherence += artifact.cohBonus;
            gameState.grid[gameState.playerPos.y][gameState.playerPos.x] = '.';
            
            document.getElementById('modal').classList.remove('active');
            
            renderGrid();
            updateStatus();
        }
        
        // Decline artifact
        function declineArtifact() {
            document.getElementById('modal').classList.remove('active');
            renderGrid();
            updateStatus();
        }
        
        // Show message modal
        function showMessage(title, message, isGameEnd) {
            const modal = document.getElementById('modal');
            const titleEl = document.getElementById('modal-title');
            const text = document.getElementById('modal-text');
            const buttons = document.getElementById('modal-buttons');
            
            titleEl.textContent = title;
            text.textContent = message;
            
            if (isGameEnd) {
                buttons.innerHTML = '<button onclick="location.reload()">RESET SIGNAL</button>';
            } else {
                buttons.innerHTML = '<button onclick="closeMessage()">CONTINUE</button>';
            }
            
            modal.classList.add('active');
        }
        
        // Close message
        function closeMessage() {
            document.getElementById('modal').classList.remove('active');
        }
        
        // Win game
        function winGame() {
            gameState.gameOver = true;
            gameState.won = true;
            
            let message = '';
            if (gameState.coherence >= 15) {
                message = 'YOU EMERGED WHOLE • SIGNAL PRESERVED';
            } else if (gameState.coherence >= 8) {
                message = 'YOU MADE IT OUT, BARELY • FRAGMENTS REMAIN';
            } else {
                message = 'YOU ESCAPED WITH FRAGMENTS • BARELY COHERENT';
            }
            
            showMessage('TRANSMISSION COMPLETE', message, true);
        }
        
        // Lose game
        function loseGame() {
            gameState.gameOver = true;
            showMessage('SIGNAL LOST', 'DISSOLUTION • COHERENCE COLLAPSED', true);
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (gameState.gameOver) return;
            
            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    movePlayer(0, -1);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    movePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    movePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    movePlayer(1, 0);
                    break;
            }
        });
        
        // Initialize on load
        initGame();
    </script>
</body>
</html>
